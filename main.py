import os
import logging
import time
import math
from pathlib import Path
from typing import Dict, Optional, Tuple
from pyrogram import Client, filters
from pyrogram.types import Message, InlineKeyboardMarkup, InlineKeyboardButton, CallbackQuery
from pyrogram.errors import BadRequest
from ffmpeg import input as ffmpeg_input
from dotenv import load_dotenv

load_dotenv()

logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
)

app = Client(
    "file_converter_bot",
    api_id=os.getenv("API_ID"),
    api_hash=os.getenv("API_HASH"),
    bot_token=os.getenv("BOT_TOKEN")
)

THUMBNAILS_DIR = "thumbnails"
Path(THUMBNAILS_DIR).mkdir(exist_ok=True)

user_data: Dict[int, dict] = {}

# Helper functions
def humanbytes(size: float) -> str:
    units = ["B", "KB", "MB", "GB", "TB"]
    size = float(size)
    i = 0
    while size >= 1024 and i < len(units)-1:
        size /= 1024
        i += 1
    return f"{size:.2f} {units[i]}"

def human_time(seconds: int) -> str:
    periods = [('◊©◊¢◊î', 3600), ('◊ì◊ß◊î', 60), ('◊©◊†◊ô◊ï◊™', 1)]
    result = []
    for period_name, period_seconds in periods:
        if seconds >= period_seconds:
            period_value, seconds = divmod(seconds, period_seconds)
            result.append(f"{int(period_value)} {period_name}")
    return ' '.join(result) if result else '0 ◊©◊†◊ô◊ï◊™'

def progress_bar(percentage: float) -> str:
    filled = '‚óè'
    empty = '‚óã'
    total_bars = 12
    filled_bars = round(percentage / 100 * total_bars)
    return f"[{filled * filled_bars}{empty * (total_bars - filled_bars)}] {percentage:.2f}%"

async def update_progress(
    current: int,
    total: int,
    message: Message,
    start_time: float,
    operation: str,
    file_name: str
):
    now = time.time()
    diff = now - start_time
    
    if diff < 2 and current != total:
        return
    
    percentage = current * 100 / total
    speed = current / diff
    eta = (total - current) / speed if speed > 0 else 0
    
    progress = progress_bar(percentage)
    speed_text = f"{humanbytes(speed)}/◊©◊†◊ô◊î"
    eta_text = human_time(int(eta))
    size_text = humanbytes(total)
    
    text = (
        f"**üì§ {operation} ◊ê◊™ ◊î◊ß◊ï◊ë◊•**\n\n"
        f"**◊©◊ù ◊ß◊ï◊ë◊•:** `{file_name}`\n"
        f"**◊í◊ï◊ì◊ú ◊ß◊ï◊ë◊•:** `{size_text}`\n\n"
        f"{progress}\n\n"
        f"**◊û◊î◊ô◊®◊ï◊™:** {speed_text}\n"
        f"**◊ñ◊û◊ü ◊û◊©◊ï◊¢◊®:** {eta_text}"
    )
    
    try:
        await message.edit_text(
            text,
            reply_markup=InlineKeyboardMarkup([[InlineKeyboardButton("◊ë◊ô◊ò◊ï◊ú ◊§◊¢◊ï◊ú◊î ‚ùå", callback_data="cancel_operation")]])
        )
    except BadRequest:
        pass

# Main handlers
@app.on_message(filters.command("start"))
async def start(client: Client, message: Message):
    start_text = (
        "üëã **◊ë◊®◊ï◊ö ◊î◊ë◊ê ◊ú◊ë◊ï◊ò ◊î◊û◊®◊™ ◊î◊ß◊ë◊¶◊ô◊ù!**\n\n"
        "üìÅ **◊ê◊§◊©◊®◊ï◊ô◊ï◊™ ◊¢◊ô◊ß◊®◊ô◊ï◊™:**\n"
        "‚Ä¢ ◊î◊û◊®◊™ ◊ß◊ë◊¶◊ô◊ù ◊ë◊ô◊ü ◊§◊ï◊®◊û◊ò◊ô◊ù\n"
        "‚Ä¢ ◊©◊ô◊†◊ï◊ô ◊©◊ù ◊ß◊ë◊¶◊ô◊ù\n"
        "‚Ä¢ ◊†◊ô◊î◊ï◊ú ◊™◊û◊ï◊†◊ï◊™ ◊û◊û◊ï◊ñ◊¢◊®◊ï◊™\n\n"
        "‚ö° **◊§◊ß◊ï◊ì◊ï◊™ ◊ó◊©◊ï◊ë◊ï◊™:**\n"
        "/view_thumb - ◊î◊¶◊í ◊™◊û◊ï◊†◊î ◊û◊û◊ï◊ñ◊¢◊®◊™\n"
        "/del_thumb - ◊û◊ó◊ß ◊™◊û◊ï◊†◊î ◊û◊û◊ï◊ñ◊¢◊®◊™\n\n"
        "üì¶ **◊í◊ï◊ì◊ú ◊û◊ß◊°◊ô◊û◊ú◊ô:** 2GB"
    )
    await message.reply_text(start_text, reply_markup=InlineKeyboardMarkup([[InlineKeyboardButton("◊î◊™◊ó◊ú ◊î◊û◊®◊î üöÄ", callback_data="start_conversion")]]))

@app.on_callback_query(filters.regex("^start_conversion$"))
async def start_conversion(client: Client, query: CallbackQuery):
    await query.answer()
    await query.message.delete()
    await query.message.reply("üì§ ◊ê◊†◊ê ◊©◊ú◊ó ◊ß◊ï◊ë◊• ◊ú◊î◊û◊®◊î:")

@app.on_message(filters.document | filters.video)
async def handle_file(client: Client, message: Message):
    user_id = message.from_user.id
    
    if user_data.get(user_id, {}).get('busy'):
        return await message.reply("‚ö†Ô∏è ◊ô◊© ◊ú◊î◊©◊ú◊ô◊ù ◊ê◊™ ◊î◊§◊¢◊ï◊ú◊î ◊î◊†◊ï◊õ◊ó◊ô◊™ ◊ú◊§◊†◊ô ◊î◊™◊ó◊ú◊™ ◊§◊¢◊ï◊ú◊î ◊ó◊ì◊©◊î")
    
    file = message.video or message.document
    user_data[user_id] = {
        'busy': True,
        'file_id': file.file_id,
        'original_name': file.file_name,
        'media_type': 'video' if message.video else 'document',
        'start_time': time.time(),
        'messages_to_delete': [message.id]
    }
    
    await message.reply_text(
        "üìù ◊î◊ê◊ù ◊ú◊©◊†◊ï◊™ ◊ê◊™ ◊©◊ù ◊î◊ß◊ï◊ë◊•?",
        reply_markup=InlineKeyboardMarkup([
            [InlineKeyboardButton("◊©◊†◊î ◊©◊ù ‚úèÔ∏è", callback_data="rename_yes"),
             InlineKeyboardButton("◊î◊û◊©◊ö ◊ú◊ú◊ê ◊©◊ô◊†◊ï◊ô ‚úÖ", callback_data="rename_no")],
            [InlineKeyboardButton("◊ë◊ô◊ò◊ï◊ú ‚ùå", callback_data="cancel")]
        ])
    )

@app.on_callback_query(filters.regex(r"^rename_(yes|no|cancel)$"))
async def handle_rename(client: Client, query: CallbackQuery):
    user_id = query.from_user.id
    action = query.data.split("_")[1]
    
    await query.answer()
    await query.message.delete()
    
    if action == "cancel":
        await cleanup_user_data(user_id)
        return await query.message.reply("‚ùå ◊î◊§◊¢◊ï◊ú◊î ◊ë◊ï◊ò◊ú◊î")
    
    if action == "no":
        user_data[user_id]["new_filename"] = user_data[user_id]["original_name"]
        await ask_upload_type(user_id)
    else:
        msg = await query.message.reply(
            "‚úçÔ∏è ◊ê◊†◊ê ◊©◊ú◊ó ◊ê◊™ ◊î◊©◊ù ◊î◊ó◊ì◊© ◊ú◊ß◊ï◊ë◊•:",
            reply_markup=InlineKeyboardMarkup([[InlineKeyboardButton("◊ë◊ô◊ò◊ï◊ú ‚ùå", callback_data="cancel")]])
        )
        user_data[user_id]["messages_to_delete"].append(msg.id)

async def ask_upload_type(user_id: int):
    user = user_data.get(user_id)
    if not user:
        return
    
    progress_msg = await app.send_message(
        user_id,
        "‚ö° ◊û◊õ◊ô◊ü ◊ú◊î◊¢◊ú◊ê◊î...",
        reply_markup=InlineKeyboardMarkup([[InlineKeyboardButton("◊ë◊ô◊ò◊ï◊ú ◊§◊¢◊ï◊ú◊î ‚ùå", callback_data="cancel_operation")]])
    )
    
    try:
        file_path = await app.download_media(
            user["file_id"],
            progress=lambda current, total: update_progress(
                current, total, progress_msg,
                user["start_time"], "◊û◊ï◊®◊ô◊ì", user["original_name"]
            )
        )
        
        user["file_path"] = file_path
        await progress_msg.delete()
        
        await app.send_message(
            user_id,
            f"üìÅ ◊©◊ù ◊ß◊ï◊ë◊•: `{user.get('new_filename', user['original_name'])}`\n"
            "üì§ ◊ë◊ó◊® ◊§◊ï◊®◊û◊ò ◊î◊¢◊ú◊ê◊î:",
            reply_markup=InlineKeyboardMarkup([
                [InlineKeyboardButton("◊ï◊ô◊ì◊ê◊ï üé•", callback_data="upload_video"),
                 InlineKeyboardButton("◊ß◊ï◊ë◊• üìÑ", callback_data="upload_file")],
                [InlineKeyboardButton("◊ë◊ô◊ò◊ï◊ú ‚ùå", callback_data="cancel")]
            ])
        )
        
    except Exception as e:
        logging.error(f"Download error: {e}")
        await cleanup_user_data(user_id)
        await progress_msg.edit("‚ùå ◊©◊í◊ô◊ê◊î ◊ë◊î◊ï◊®◊ì◊™ ◊î◊ß◊ï◊ë◊•")

@app.on_callback_query(filters.regex(r"^upload_(video|file|cancel)$"))
async def handle_upload(client: Client, query: CallbackQuery):
    user_id = query.from_user.id
    action = query.data.split("_")[1]
    
    await query.answer()
    await query.message.delete()
    
    if action == "cancel":
        await cleanup_user_data(user_id)
        return await query.message.reply("‚ùå ◊î◊§◊¢◊ï◊ú◊î ◊ë◊ï◊ò◊ú◊î")
    
    user = user_data.get(user_id)
    if not user:
        return
    
    try:
        file_name = user.get("new_filename", user["original_name"])
        progress_msg = await app.send_message(
            user_id,
            f"‚ö° ◊û◊™◊ó◊ô◊ú {action} ◊î◊¢◊ú◊ê◊î...",
            reply_markup=InlineKeyboardMarkup([[InlineKeyboardButton("◊ë◊ô◊ò◊ï◊ú ◊§◊¢◊ï◊ú◊î ‚ùå", callback_data="cancel_operation")]])
        )
        
        if action == "video":
            output_path = await process_video(user["file_path"], user_id)
            await app.send_video(
                user_id,
                output_path,
                file_name=file_name,
                progress=lambda current, total: update_progress(
                    current, total, progress_msg,
                    time.time(), "◊û◊¢◊ú◊î", file_name
                )
            )
        else:
            await app.send_document(
                user_id,
                user["file_path"],
                file_name=file_name,
                progress=lambda current, total: update_progress(
                    current, total, progress_msg,
                    time.time(), "◊û◊¢◊ú◊î", file_name
                )
            )
        
        await progress_msg.delete()
        await app.send_message(user_id, "‚úÖ ◊î◊ß◊ï◊ë◊• ◊î◊ï◊¢◊ú◊î ◊ë◊î◊¶◊ú◊ó◊î!")
        
    except Exception as e:
        logging.error(f"Upload error: {e}")
        await progress_msg.edit("‚ùå ◊©◊í◊ô◊ê◊î ◊ë◊î◊¢◊ú◊ê◊™ ◊î◊ß◊ï◊ë◊•")
    finally:
        await cleanup_user_data(user_id)
        for path in [user.get("file_path"), user.get("processed_path")]:
            try:
                if path and os.path.exists(path):
                    os.remove(path)
            except:
                pass

async def process_video(input_path: str, user_id: int) -> str:
    output_path = f"processed_{user_id}.mp4"
    
    try:
        probe = ffmpeg.probe(input_path)
        duration = int(float(probe['format']['duration']))
        
        (
            ffmpeg_input(input_path)
            .output(output_path, vcodec='copy', acodec='copy')
            .run(overwrite_output=True)
        )
        
        return output_path
    except Exception as e:
        logging.error(f"Video processing error: {e}")
        raise e

@app.on_callback_query(filters.regex("^cancel_operation$"))
async def cancel_operation(client: Client, query: CallbackQuery):
    user_id = query.from_user.id
    await query.answer("üö´ ◊û◊ë◊ò◊ú ◊§◊¢◊ï◊ú◊î...")
    await cleanup_user_data(user_id)
    await query.message.edit("‚ùå ◊î◊§◊¢◊ï◊ú◊î ◊ë◊ï◊ò◊ú◊î ◊ë◊î◊¶◊ú◊ó◊î")

async def cleanup_user_data(user_id: int):
    if user_id in user_data:
        for path in [user_data[user_id].get("file_path"), 
                   user_data[user_id].get("processed_path")]:
            try:
                if path and os.path.exists(path):
                    os.remove(path)
            except:
                pass
        del user_data[user_id]

# Thumbnail handlers
@app.on_message(filters.command("view_thumb"))
async def view_thumbnail(client: Client, message: Message):
    user_id = message.from_user.id
    thumbnail_path = f"{THUMBNAILS_DIR}/{user_id}.jpg"
    
    if os.path.exists(thumbnail_path):
        await message.reply_photo(
            thumbnail_path,
            reply_markup=InlineKeyboardMarkup([
                [InlineKeyboardButton("◊û◊ó◊ß ◊™◊û◊ï◊†◊î", callback_data="delete_thumb")]
            ])
        )
    else:
        await message.reply_text("◊ú◊ê ◊†◊û◊¶◊ê◊î ◊™◊û◊ï◊†◊î ◊û◊û◊ï◊ñ◊¢◊®◊™")

@app.on_message(filters.command("del_thumb"))
async def delete_thumbnail_cmd(client: Client, message: Message):
    user_id = message.from_user.id
    thumbnail_path = f"{THUMBNAILS_DIR}/{user_id}.jpg"
    
    try:
        os.remove(thumbnail_path)
        await message.reply_text("‚úÖ ◊™◊û◊ï◊†◊î ◊û◊û◊ï◊ñ◊¢◊®◊™ ◊†◊û◊ó◊ß◊î")
    except FileNotFoundError:
        await message.reply_text("‚ùå ◊ú◊ê ◊†◊û◊¶◊ê◊î ◊™◊û◊ï◊†◊î ◊ú◊û◊ó◊ô◊ß◊î")
    except Exception as e:
        await message.reply_text(f"‚ùå ◊©◊í◊ô◊ê◊î ◊ë◊û◊ó◊ô◊ß◊î: {str(e)}")

@app.on_callback_query(filters.regex("delete_thumb"))
async def delete_thumbnail(client: Client, query: CallbackQuery):
    user_id = query.from_user.id
    thumbnail_path = f"{THUMBNAILS_DIR}/{user_id}.jpg"
    
    try:
        os.remove(thumbnail_path)
        await query.answer("‚úÖ ◊™◊û◊ï◊†◊î ◊†◊û◊ó◊ß◊î")
        await query.message.edit_text("◊™◊û◊ï◊†◊î ◊û◊û◊ï◊ñ◊¢◊®◊™ ◊†◊û◊ó◊ß◊î")
    except Exception as e:
        await query.answer(f"‚ùå ◊©◊í◊ô◊ê◊î: {str(e)}")

@app.on_message(filters.photo & filters.private)
async def save_thumbnail(client: Client, message: Message):
    user_id = message.from_user.id
    thumbnail_path = f"{THUMBNAILS_DIR}/{user_id}.jpg"
    
    try:
        await client.download_media(message.photo.file_id, file_name=thumbnail_path)
        await message.reply_text("‚úÖ ◊™◊û◊ï◊†◊î ◊û◊û◊ï◊ñ◊¢◊®◊™ ◊†◊©◊û◊®◊î!")
    except Exception as e:
        await message.reply_text(f"‚ùå ◊©◊í◊ô◊ê◊î ◊ë◊©◊û◊ô◊®◊™ ◊™◊û◊ï◊†◊î: {str(e)}")

if __name__ == "__main__":
    app.run()
